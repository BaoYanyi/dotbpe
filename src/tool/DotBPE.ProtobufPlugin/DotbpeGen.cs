using Google.Protobuf.Compiler;
using Google.Protobuf.Reflection;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace DotBPE.ProtobufPlugin
{
    public class DotbpeGen
    {
        public static void Generate(CodeGeneratorRequest request, CodeGeneratorResponse response)
        {
            foreach (var protofile in request.ProtoFile)
            {
                try{
                    GenerateByProtoFile(protofile, response);
                }
                catch(Exception ex){
                    using (Stream stream = File.Create("./error.txt"))
                    {
                        byte[] err = Encoding.UTF8.GetBytes(ex.Message+ex.StackTrace);
                        stream.Write(err,0,err.Length);
                    }
                    response.Error += ex.Message;
                }
            }
        }

        private static void GenerateSourceInfo(FileDescriptorProto protofile, CodeGeneratorResponse response)
        {
            bool genericDoc;
            protofile.Options.CustomOptions.TryGetBool(DotBPEOptions.GENERIC_MARKDOWN_DOC,out genericDoc);
            if (!genericDoc)
            {
                return;
            }
            StringBuilder sb = new StringBuilder();
            foreach (var location in protofile.SourceCodeInfo.Location)
            {
                string path = String.Join(",", location.Path);
                string span = String.Join(",", location.Span);
                string leadingDetachedComments = String.Join("\r", location.LeadingDetachedComments);
                string trailingComments = String.Join("\r", location.TrailingComments);
                sb.AppendLine("{\"Path\",\""+path+"\",\"Span\",\""+span+"\",\"LeadingComments\",\""+ location.LeadingComments + "\",\"LeadingDetachedComments\",\""+ leadingDetachedComments + "\",\"TrailingComments\",\""+ trailingComments + "\"}");
                
            }
            var nfile = new CodeGeneratorResponse.Types.File
            {
                Name = GetFileName(protofile.Name) + "SI.txt",
                Content = sb.ToString()
            };
            response.File.Add(nfile);
        }
        private static void GenerateByProtoFile(FileDescriptorProto protofile, CodeGeneratorResponse response)
        {
            GenerateSourceInfo(protofile, response);
            GenerateServer(protofile, response);
            GenerateClient(protofile, response);

        }
        private static void GenerateServer(FileDescriptorProto protofile, CodeGeneratorResponse response)
        {
            bool genericServer;
            protofile.Options.CustomOptions.TryGetBool(DotBPEOptions.DISABLE_GENERIC_SERVICES_SERVER, out genericServer);
            if (genericServer)
            {
                return;
            }
            if (protofile.Service == null || protofile.Service.Count <= 0) return;
            //生成文件头
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// Generated by the protocol buffer compiler.  DO NOT EDIT!");
            sb.AppendLine($"// source: {protofile.Name}");
            //还可以生成注释

            sb.AppendLine("#region Designer generated code");
            sb.AppendLine("");
            sb.AppendLine("using System; ");
            sb.AppendLine("using System.Threading.Tasks; ");
            sb.AppendLine("using DotBPE.Rpc; ");
            sb.AppendLine("using DotBPE.Protocol.Amp; ");
            sb.AppendLine("using Google.Protobuf; ");
            sb.AppendLine("");

            string ns = GetFileNamespace(protofile);
            sb.AppendLine("namespace " + ns + " {");
            //生成代码
            foreach (ServiceDescriptorProto t in protofile.Service)
            {
                t.Options.CustomOptions.TryGetBool(DotBPEOptions.DISABLE_GENERIC_SERVICES_SERVER, out genericServer);
                if (genericServer)
                {
                    continue;
                }

                sb.AppendLine("");
                sb.AppendLine("//start for class Abstract"+t.Name);
                GenerateServiceForServer(t, sb);
                sb.AppendLine("//end for class Abstract"+t.Name);
            }
            sb.AppendLine("}\n");
            sb.AppendLine("#endregion\n");

            var nfile = new CodeGeneratorResponse.Types.File
            {
                Name = GetFileName(protofile.Name) + "Server.cs",
                Content = sb.ToString()
            };
            response.File.Add(nfile);
        }
        private static void GenerateClient(FileDescriptorProto protofile, CodeGeneratorResponse response)
        {
            bool genericClient;
            protofile.Options.CustomOptions.TryGetBool(DotBPEOptions.DISABLE_GENERIC_SERVICES_CLIENT, out genericClient);
            if (genericClient)
            {
                return;
            }
            if (protofile.Service == null || protofile.Service.Count <= 0) return;
            //生成文件头
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// Generated by the protocol buffer compiler.  DO NOT EDIT!");
            sb.AppendLine($"// source: {protofile.Name}");
            //还可以生成注释

            sb.AppendLine("#region Designer generated code");
            sb.AppendLine("");
            sb.AppendLine("using System; ");
            sb.AppendLine("using System.Threading.Tasks; ");
            sb.AppendLine("using DotBPE.Rpc; ");
            sb.AppendLine("using DotBPE.Protocol.Amp; ");
            sb.AppendLine("using DotBPE.Rpc.Exceptions; ");
            sb.AppendLine("using Google.Protobuf; ");
            sb.AppendLine("");

            string ns = GetFileNamespace(protofile);
            sb.AppendLine("namespace " + ns + " {");
            //生成代码

            foreach (ServiceDescriptorProto t in protofile.Service)
            {
                t.Options.CustomOptions.TryGetBool(DotBPEOptions.DISABLE_GENERIC_SERVICES_CLIENT, out genericClient);
                if (genericClient)
                {
                    continue;
                }
                sb.AppendLine("");
                sb.AppendLine("//start for class "+t.Name+"Client");
                GenerateServiceForClient(t, sb);
                sb.AppendLine("//end for class "+t.Name+"Client");
            }
            sb.AppendLine("}");
            sb.AppendLine("#endregion");

            //生成文件
            var nfile = new CodeGeneratorResponse.Types.File
            {
                Name = GetFileName(protofile.Name) + "Client.cs",
                Content = sb.ToString()
            };
            response.File.Add(nfile);
        }

        private static void GenerateServiceForClient(ServiceDescriptorProto service, StringBuilder sb)
        {
            int serviceId;
            bool hasServiceId = service.Options.CustomOptions.TryGetInt32(DotBPEOptions.SERVICE_ID, out serviceId);
            if (!hasServiceId || serviceId <= 0)
            {
                throw new Exception("Service=" + service.Name + " ServiceId NOT_FOUND");
            }
            if (serviceId >= ushort.MaxValue)
            {
                throw new Exception("Service=" + service.Name + "ServiceId too large");
            }

            sb.AppendFormat("public sealed class {0}Client : AmpInvokeClient \n",service.Name);
            sb.AppendLine("{");
            //构造函数
            sb.AppendLine($"public {service.Name}Client(IRpcClient<AmpMessage> client) : base(client)");
            sb.AppendLine("{");
            sb.AppendLine("}");

            //循环方法
            foreach (var method in service.Method)
            {
                int msgId ;
                bool hasMsgId= method.Options.CustomOptions.TryGetInt32(DotBPEOptions.MESSAGE_ID,out msgId);
                if (!hasMsgId || msgId <= 0)
                {
                    throw new Exception("Service" + service.Name + "." + method.Name + " ' MessageId NOT_FINDOUT ");
                }
                if (msgId >= ushort.MaxValue)
                {
                    throw new Exception("Service" + service.Name + "." + method.Name + " is too large");
                }
                //异步方法
                string outType = GetTypeName(method.OutputType);
                string inType = GetTypeName(method.InputType);

                sb.AppendLine($"public async Task<{outType}> {method.Name}Async({inType} request,int timeOut=3000)");
                sb.AppendLine("{");
                sb.AppendLine($"AmpMessage message = AmpMessage.CreateRequestMessage({serviceId}, {msgId});");
                sb.AppendLine("message.Data = request.ToByteArray();");
                sb.AppendLine("var response = await base.CallInvoker.AsyncCall(message,timeOut);");
                sb.AppendLine("if (response != null && response.Data !=null)");
                sb.AppendLine("{");
                sb.AppendLine($"return {outType}.Parser.ParseFrom(response.Data);");
                sb.AppendLine("}");
                sb.AppendLine("throw new RpcException(\"请求出错，请检查!\");");
                sb.AppendLine("}");
                sb.AppendLine();
                sb.AppendLine("//同步方法");
                sb.AppendLine($"public {outType} {method.Name}({inType} request)");
                sb.AppendLine("{");
                sb.AppendLine($"AmpMessage message = AmpMessage.CreateRequestMessage({serviceId}, {msgId});");
                sb.AppendLine("message.Data = request.ToByteArray();");
                sb.AppendLine("var response =  base.CallInvoker.BlockingCall(message);");
                sb.AppendLine("if (response != null && response.Data !=null)");
                sb.AppendLine("{");
                sb.AppendLine($"return {outType}.Parser.ParseFrom(response.Data);");
                sb.AppendLine("}");
                sb.AppendLine("throw new RpcException(\"请求出错，请检查!\");");
                sb.AppendLine("}");
            }
            //循环方法end

            sb.AppendLine("}");
            //类结束

        }
        private static void GenerateServiceForServer(ServiceDescriptorProto service, StringBuilder sb)
        {
            int serviceId;
            bool hasServiceId = service.Options.CustomOptions.TryGetInt32(DotBPEOptions.SERVICE_ID, out serviceId);
            if(!hasServiceId || serviceId<=0){
                throw new Exception("Service="+service.Name+" ServiceId NOT_FOUND");
            }
            if(serviceId>=ushort.MaxValue){
                throw new Exception("Service="+service.Name+ "ServiceId too large" );
            }

            sb.AppendFormat("public abstract class {0}Base : IServiceActor<AmpMessage> \n", service.Name);
            sb.AppendLine("{");
            sb.AppendLine("public string Id => \""+serviceId+"$0\";");



            StringBuilder sbIfState = new StringBuilder();

            //循环方法
            foreach (var method in service.Method)
            {
                int msgId ;
                bool hasMsgId= method.Options.CustomOptions.TryGetInt32(DotBPEOptions.MESSAGE_ID,out msgId);
                if(!hasMsgId || msgId<=0){
                    throw new Exception("Service"+service.Name+"."+method.Name+" ' MessageId NOT_FINDOUT ");
                }
                if(msgId>=ushort.MaxValue){
                    throw new Exception("Service" + service.Name+"."+method.Name+" is too large");
                }
                //异步方法
                string outType = GetTypeName(method.OutputType);
                string inType = GetTypeName(method.InputType);


                sb.AppendLine("//调用委托");
                sb.AppendLine(
                    $"private async Task Receive{method.Name}Async(IRpcContext<AmpMessage> context, AmpMessage req)");
                sb.AppendLine("{");
                sb.AppendLine($"var request = {inType}.Parser.ParseFrom(req.Data);");
                sb.AppendLine($"var data = await {method.Name}Async(request);");
                sb.AppendLine("var response = AmpMessage.CreateResponseMessage(req.ServiceId, req.MessageId);");
                sb.AppendLine("response.Sequence = req.Sequence;");
                sb.AppendLine("response.Data = data.ToByteArray();");
                sb.AppendLine("await context.SendAsync(response);");
                sb.AppendLine("}");

                sb.AppendLine();


                sb.AppendLine("//抽象方法");
                sb.AppendLine($"public abstract Task<{outType}> {method.Name}Async({inType} request);");

                //拼装if调用语句
                sbIfState.AppendFormat("//方法{0}.{1}\n",service.Name,method.Name);
                sbIfState.AppendLine("if(req.MessageId == "+msgId+"){return this.Receive"+method.Name+"Async(context, req);}");
            }
            //循环方法end
            //生成主调用代码
            sb.AppendLine("public Task ReceiveAsync(IRpcContext<AmpMessage> context, AmpMessage req)");
            sb.AppendLine("{");
            sb.Append(sbIfState);
            sb.AppendLine("return Task.CompletedTask;");
            sb.AppendLine("}");


            sb.AppendLine("}");
            //类结束

        }
        private static string GetFileNamespace(FileDescriptorProto protofile)
        {
            string ns = protofile.Options.CsharpNamespace;
            if (string.IsNullOrEmpty(ns))
            {
                throw new Exception("" + protofile.Name + ".proto did not set csharp_namespace");
            }
            return ConvertCamelCase(ns);
        }

        private static string GetFileName(string fileProto)
        {
            string nomalName = fileProto.Split('.')[0];
            return ConvertCamelCase(nomalName);
        }

        private static string ConvertCamelCase(string nomalName)
        {
            return String.Join("", nomalName.Split('_').Select(_ => _.Substring(0, 1).ToUpper() + _.Substring(1)));
        }

        private static string GetTypeName(string typeFullName)
        {
            return ConvertCamelCase(typeFullName.Split('.').Last());
        }
    }
}
